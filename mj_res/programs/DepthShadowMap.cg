
void casterVP(float4           position: POSITION,
              out float4       outPos:   POSITION,
              out float2       outDepth: TEXCOORD0,
              uniform float4x4 worldViewProj,
              uniform float4   texelOffsets,
              uniform float4   depthRange) {
    outPos = mul(worldViewProj, position);
    // Fix pixel/texel alignment.
    outPos.xy += texelOffsets.zw * outPos.w;
    // Linear depth storage.
    // Offset / scale range output.
#if LINEAR_RANGE
    outDepth.x = (outPos.z - depthRange.x) * depthRange.w;
#else
    outDepth.x = outPos.z;
#endif
    outDepth.y = outPos.w;
}

void casterFP(float2     depth:  TEXCOORD0,
              out float4 result: COLOR) {
#if LINEAR_RANGE
    float finalDepth = depth.x;
#else
    float finalDepth = depth.x / depth.y;
#endif
    result = float4(finalDepth, finalDepth, finalDepth, 1);
}

void receiverVP(float4           position:    POSITION,
                float4           normal:      NORMAL,
                out float4       outPos:      POSITION,
                out float4       outColour:   COLOR,
                out float4       outShadowUV: TEXCOORD0,
                uniform float4x4 world,
                uniform float4x4 worldIT,
                uniform float4x4 worldViewProj,
                uniform float4x4 texViewProj,
                uniform float4   lightPosition,
                uniform float4   lightColour,
                uniform float4   shadowDepthRange) {
    float4 worldPos = mul(world, position);
    outPos = mul(worldViewProj, position);
    float3 worldNorm = mul(worldIT, normal).xyz;
    float3 lightDir = normalize(lightPosition.xyz - (worldPos.xyz * lightPosition.w));
    outColour = lightColour * max(dot(lightDir, worldNorm), 0.0);
    outShadowUV = mul(texViewProj, worldPos);
#if LINEAR_RANGE
    outShadowUV.z = (outShadowUV.z - shadowDepthRange.x) * shadowDepthRange.w;
#endif
}

void receiverFP(float4            position:     POSITION,
                float4            shadowUV:     TEXCOORD0,
                float4            vertexColour: COLOR,
                out float4        result:       COLOR,
                uniform sampler2D shadowMap:    register(s0),
                uniform float     inverseShadowMapSize,
                uniform float     fixedDepthBias,
                uniform float     gradientClamp,
                uniform float     gradientScaleBias,
                uniform float     shadowFuzzyWidth) {
#if LINEAR_RANGE
    shadowUV.xy = shadowUV.xy / shadowUV.w;
#else
    shadowUV = shadowUV / shadowUV.w;
#endif
    float centerdepth = tex2D(shadowMap, shadowUV.xy).x;
    float pixeloffset = inverseShadowMapSize;
    float4 depths = float4(tex2D(shadowMap, shadowUV.xy + float2(-pixeloffset, 0)).x,
                           tex2D(shadowMap, shadowUV.xy + float2(+pixeloffset, 0)).x,
                           tex2D(shadowMap, shadowUV.xy + float2(0, -pixeloffset)).x,
                           tex2D(shadowMap, shadowUV.xy + float2(0, +pixeloffset)).x);
    float2 differences = abs(depths.yw - depths.xz);
    float gradient = min(gradientClamp, max(differences.x, differences.y));
    float gradientFactor = gradient * gradientScaleBias;
    float depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);
    float finalCenterDepth = centerdepth  + depthAdjust;
#if FUZZY_TEST
    float visibility =saturate(1 + (finalCenterDepth - shadowUV.z) * shadowFuzzyWidth * shadowUV.w);
    result = vertexColour * visibility;
#else
#if PCF
    depths += depthAdjust.xxxx;
    float final = (finalCenterDepth > shadowUV.z) ? 1.0f : 0.0f;
    final += (depths.x > shadowUV.z) ? 1.0f : 0.0f;
    final += (depths.y > shadowUV.z) ? 1.0f : 0.0f;
    final += (depths.z > shadowUV.z) ? 1.0f : 0.0f;
    final += (depths.w > shadowUV.z) ? 1.0f : 0.0f;
    final *= 0.2f;
    result = float4(vertexColour.xyz * final, 1);
#else
    result = (finalCenterDepth > shadowUV.z) ? vertexColour : float4(0, 0, 0, 1);
#endif
#endif
}

void ambientOneTextureVP(float4           position:  POSITION,
                         float2           uv:        TEXCOORD0,
                         out float4       outPos:    POSITION,
                         out float2       outUV:     TEXCOORD0,
                         out float4       outColour: COLOR,
                         uniform float4x4 worldViewProj,
                         uniform float4   ambient) {
    outPos = mul(worldViewProj, position);
    outUV = uv;
    outColour = ambient;
}

